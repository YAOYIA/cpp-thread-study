### c++并发编程（三）条件变量（Condition Variable）
条件变量的一般用法，线程A等待某个条件并挂起，直到线程B设置了这个条件，并通知条件变量，然后线程A被唤起。经典的生产者-消费者问题可以通过条件变量来解决。
这里的等待线程可以是多个，通知线程可以选择一次通知一个（notify_one）或者一次通知所有(notify_all)。

**条件变量**是一种同步机制，用来阻塞一个或多个线程，直到收到特定的通知或条件被满足。条件变量通常与互斥锁（std::mutex）一起使用，以保护条件检查和条件变量等待/通知操作的原子性。

## 条件变量主要涉及以下几个关键点：

# 等待条件（Waiting for a Condition）：
线程使用条件变量来等待某个条件的发生。当线程调用条件变量的wait方法时，它会自动释放与之关联的互斥锁，并进入阻塞状态。这样可以避免忙等待（busy-waiting），节省处理器资源。

# 通知（Notification）：
当条件发生变化时（比如被另一个线程修改），需要通知等待条件变量的线程。这可以通过调用条件变量的notify_one或notify_all方法来实现。notify_one仅唤醒一个等待线程，而notify_all会唤醒所有等待线程。

# 互斥锁（Mutex）的作用：
互斥锁用来同步对共享数据的访问，确保在检查条件和修改条件时不会发生数据竞争。

# 使用范例：
条件变量通常用于生产者-消费者模式，其中生产者线程生成数据，消费者线程消费数据。当没有数据可消费时，消费者线程等待条件变量，直到生产者线程生成新数据并发送通知。

# std::condition_variable的wait方法主要接受两个参数
唯一锁（Unique Lock）:
这个参数是一个std::unique_lock<std::mutex>类型的对象，它必须在调用wait之前锁定相应的互斥量（mutex）。unique_lock是一个作用域锁，它提供了比std::lock_guard更灵活的锁定和解锁操作，包括能够在不销毁锁对象的情况下手动解锁和重新锁定。
谓词（Predicate）:
这是一个可选参数，通常是一个返回布尔值的函数或者Lambda表达式。谓词用于指定等待应该在何种条件下结束。wait方法会重复检查这个谓词，只有当谓词返回true时，等待才会结束。这个机制帮助防止虚假唤醒和错误的通知。
wait方法的工作方式是先检查谓词，如果谓词返回false（或者没有提供谓词），它会自动释放锁并使线程进入等待状态。当条件变量接收到通知时，线程会被唤醒，重新获取锁，并再次检查谓词。如果谓词为true，或者在重新检查之后变为true，则wait结束，线程继续执行