# c++并发变成：Mutex（互斥锁）
多个线程访问同意资源时，为了保证数据的一致性，最简单的方法时使用mutex（互斥锁）

互斥量（Mutex，全称Mutual Exclusion）是一种用于控制对共享资源的访问，以防止数据竞争和条件竞争的机制。在C++中，互斥量是通过<mutex>库提供的。

使用互斥量的基本思路是在访问共享资源之前锁定（lock）互斥量，访问完毕后释放（unlock）互斥量。这样可以确保在任意时刻，只有一个线程能够访问该资源。


## 创建一组线程
直接操作mutex，即调用mutex的lock/unlock函数
可惜的是STL没有提供boost::thread_group这样代表一组线程的工具，通过std::vector固然可以达到目的，但是代码不够简洁。

#使用lock_guard自动加锁、解锁。原理时RAII和智能指针类似
std::lock_guard 是一个简单的互斥包装器，它在构造时自动锁定互斥量，并在其自身被销毁（如离开作用域）时自动解锁。它不提供显式的锁定和解锁操作，也不能转移所有权或临时解锁。
std::unique_lock 比 std::lock_guard 更灵活。它也会在构造时锁定互斥量，但提供了更多功能，例如可以延迟锁定，可以手动解锁和重新锁定，以及可以移动所有权。它在销毁时自动解锁互斥量。

## 线程安全
为输出流使用单独的mutex，这样做是因为IO流并不是线程安全的，如果不对IO进行同步，此例的输出会改变